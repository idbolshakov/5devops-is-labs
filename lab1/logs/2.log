# Вернитесь в домашний каталог, используя команду cd без параметров:



---


# Ознакомьтесь с возможностями команды mkdir c помощью команды man:

MKDIR(1)                    General Commands Manual                   MKDIR(1)

NNAAMMEE
     mmkkddiirr – make directories

SSYYNNOOPPSSIISS
     mmkkddiirr [--ppvv] [--mm _m_o_d_e] _d_i_r_e_c_t_o_r_y___n_a_m_e _._._.

DDEESSCCRRIIPPTTIIOONN
     The mmkkddiirr utility creates the directories named as operands, in the order
     specified, using mode “rwxrwxrwx” (0777) as modified by the current
     umask(2).

     The options are as follows:

     --mm _m_o_d_e        Set the file permission bits of the final created
                    directory to the specified mode.  The _m_o_d_e argument can be
                    in any of the formats specified to the chmod(1) command.
                    If a symbolic mode is specified, the operation characters
                    ‘+’ and ‘-’ are interpreted relative to an initial mode of
                    “a=rwx”.

     --pp             Create intermediate directories as required.  If this
                    option is not specified, the full path prefix of each
                    operand must already exist.  On the other hand, with this
                    option specified, no error will be reported if a directory
                    given as an operand already exists.  Intermediate
                    directories are created with permission bits of
                    “rwxrwxrwx” (0777) as modified by the current umask, plus
                    write and search permission for the owner.

     --vv             Be verbose when creating directories, listing them as they
                    are created.

     The user must have write permission in the parent directory.

EEXXIITT SSTTAATTUUSS
     The mmkkddiirr utility exits 0 on success, and >0 if an error occurs.

EEXXAAMMPPLLEESS
     Create a directory named _f_o_o_b_a_r:

           $ mkdir foobar

     Create a directory named _f_o_o_b_a_r and set its file mode to 700:

           $ mkdir -m 700 foobar

     Create a directory named _c_o_w_/_h_o_r_s_e_/_m_o_n_k_e_y, creating any non-existent
     intermediate directories as necessary:

           $ mkdir -p cow/horse/monkey

CCOOMMPPAATTIIBBIILLIITTYY
     The --vv option is non-standard and its use in scripts is not recommended.

SSEEEE AALLSSOO
     rmdir(1)

SSTTAANNDDAARRDDSS
     The mmkkddiirr utility is expected to be IEEE Std 1003.2 (“POSIX.2”)
     compatible.

HHIISSTTOORRYY
     A mmkkddiirr command appeared in Version 1 AT&T UNIX.

macOS 15.0                      March 15, 2013                      macOS 15.0


---


# Создайте каталог «test», используя команду mkdir:



---


# Перейдите в каталог «test», используя команду cd:



---


# Просмотрите содержимое каталога, используя команду ls:



---


# Создайте каталог «test2», используя команду mkdir:



---


# Ознакомьтесь с возможностями команды touch c помощью команды man:

TOUCH(1)                    General Commands Manual                   TOUCH(1)

NNAAMMEE
     ttoouucchh – change file access and modification times

SSYYNNOOPPSSIISS
     ttoouucchh [--AA _[_-_]_[_[_h_h_]_m_m_]_S_S] [--aacchhmm] [--rr _f_i_l_e] [--tt _[_[_C_C_]_Y_Y_]_M_M_D_D_h_h_m_m_[_._S_S_]]
           [--dd _Y_Y_Y_Y_-_M_M_-_D_D_T_h_h_:_m_m_:_S_S_[_._f_r_a_c_]_[_t_z_]] _f_i_l_e _._._.

DDEESSCCRRIIPPTTIIOONN
     The ttoouucchh utility sets the modification and access times of files.  If
     any file does not exist, it is created with default permissions.

     By default, ttoouucchh changes both modification and access times.  The --aa and
     --mm flags may be used to select the access time or the modification time
     individually.  Selecting both is equivalent to the default.  By default,
     the timestamps are set to the current time.  The --dd and --tt flags
     explicitly specify a different time, and the --rr flag specifies to set the
     times those of the specified file.  The --AA flag adjusts the values by a
     specified amount.

     The following options are available:

     --AA      Adjust the access and modification time stamps for the file by
             the specified value.  This flag is intended for use in modifying
             files with incorrectly set time stamps.

             The argument is of the form “[-][[hh]mm]SS” where each pair of
             letters represents the following:

                   _-       Make the adjustment negative: the new time stamp is
                           set to be before the old one.
                   _h_h      The number of hours, from 00 to 99.
                   _m_m      The number of minutes, from 00 to 59.
                   _S_S      The number of seconds, from 00 to 59.

             The --AA flag implies the --cc flag: if any file specified does not
             exist, it will be silently ignored.

     --aa      Change the access time of the file.  The modification time of the
             file is not changed unless the --mm flag is also specified.

     --cc      Do not create the file if it does not exist.  The ttoouucchh utility
             does not treat this as an error.  No error messages are displayed
             and the exit value is not affected.

     --dd      Change the access and modification times to the specified date
             time instead of the current time of day.  The argument is of the
             form “YYYY-MM-DDThh:mm:SS[.frac][tz]” where the letters represent
             the following:
                   _Y_Y_Y_Y    At least four decimal digits representing the year.
                   _M_M, _D_D, _h_h, _m_m, _S_S
                           As with --tt time.
                   _T       The letter T or a space is the time designator.
                   _._f_r_a_c   An optional fraction, consisting of a period or a
                           comma followed by one or more digits.  The number
                           of significant digits depends on the kernel
                           configuration and the filesystem, and may be zero.
                   _t_z      An optional letter Z indicating the time is in UTC.
                           Otherwise, the time is assumed to be in local time.
                           Local time is affected by the value of the TZ
                           environment variable.

     --hh      If the file is a symbolic link, change the times of the link
             itself rather than the file that the link points to.  Note that
             --hh implies --cc and thus will not create any new files.

     --mm      Change the modification time of the file.  The access time of the
             file is not changed unless the --aa flag is also specified.

     --rr      Use the access and modifications times from the specified file
             instead of the current time of day.

     --tt      Change the access and modification times to the specified time
             instead of the current time of day.  The argument is of the form
             “[[CC]YY]MMDDhhmm[.SS]” where each pair of letters represents the
             following:

                   _C_C      The first two digits of the year (the century).
                   _Y_Y      The second two digits of the year.  If “YY” is
                           specified, but “CC” is not, a value for “YY”
                           between 69 and 99 results in a “CC” value of 19.
                           Otherwise, a “CC” value of 20 is used.
                   _M_M      The month of the year, from 01 to 12.
                   _D_D      the day of the month, from 01 to 31.
                   _h_h      The hour of the day, from 00 to 23.
                   _m_m      The minute of the hour, from 00 to 59.
                   _S_S      The second of the minute, from 00 to 60.

             If the “CC” and “YY” letter pairs are not specified, the values
             default to the current year.  If the “SS” letter pair is not
             specified, the value defaults to 0.

EEXXIITT SSTTAATTUUSS
     The ttoouucchh utility exits 0 on success, and >0 if an error occurs.

CCOOMMPPAATTIIBBIILLIITTYY
     The obsolescent form of ttoouucchh, where a time format is specified as the
     first argument, is supported.  When no --rr or --tt option is specified,
     there are at least two arguments, and the first argument is a string of
     digits either eight or ten characters in length, the first argument is
     interpreted as a time specification of the form “MMDDhhmm[YY]”.

     The “MM”, “DD”, “hh” and “mm” letter pairs are treated as their
     counterparts specified to the --tt option.  If the “YY” letter pair is in
     the range 39 to 99, the year is set to 1939 to 1999, otherwise, the year
     is set in the 21st century.

SSEEEE AALLSSOO
     utimensat(2)

SSTTAANNDDAARRDDSS
     The ttoouucchh utility is expected to be a superset of the IEEE Std 1003.2
     (“POSIX.2”) specification.

HHIISSTTOORRYY
     A ttoouucchh utility appeared in Version 7 AT&T UNIX.

macOS 15.0                       June 1, 2018                       macOS 15.0


---


# Создайте файл «text» в каталоге «test2» используя команду touch:



---


# Ознакомьтесь с возможностями команды mv c помощью команды man:

MV(1)                       General Commands Manual                      MV(1)

NNAAMMEE
     mmvv – move files

SSYYNNOOPPSSIISS
     mmvv [--ff | --ii | --nn] [--hhvv] _s_o_u_r_c_e _t_a_r_g_e_t
     mmvv [--ff | --ii | --nn] [--vv] _s_o_u_r_c_e _._._. _d_i_r_e_c_t_o_r_y

DDEESSCCRRIIPPTTIIOONN
     In its first form, the mmvv utility renames the file named by the _s_o_u_r_c_e
     operand to the destination path named by the _t_a_r_g_e_t operand.  This form
     is assumed when the last operand does not name an already existing
     directory.

     In its second form, mmvv moves each file named by a _s_o_u_r_c_e operand to a
     destination file in the existing directory named by the _d_i_r_e_c_t_o_r_y
     operand.  The destination path for each operand is the pathname produced
     by the concatenation of the last operand, a slash, and the final pathname
     component of the named file.

     The following options are available:

     --ff      Do not prompt for confirmation before overwriting the destination
             path.  (The --ff option overrides any previous --ii or --nn options.)

     --hh      If the _t_a_r_g_e_t operand is a symbolic link to a directory, do not
             follow it.  This causes the mmvv utility to rename the file _s_o_u_r_c_e
             to the destination path _t_a_r_g_e_t rather than moving _s_o_u_r_c_e into the
             directory referenced by _t_a_r_g_e_t.

     --ii      Cause mmvv to write a prompt to standard error before moving a file
             that would overwrite an existing file.  If the response from the
             standard input begins with the character ‘y’ or ‘Y’, the move is
             attempted.  (The --ii option overrides any previous --ff or --nn
             options.)

     --nn      Do not overwrite an existing file.  (The --nn option overrides any
             previous --ff or --ii options.)

     --vv      Cause mmvv to be verbose, showing files after they are moved.

     It is an error for the _s_o_u_r_c_e operand to specify a directory if the
     target exists and is not a directory.

     If the destination path does not have a mode which permits writing, mmvv
     prompts the user for confirmation as specified for the --ii option.

     As the rename(2) call does not work across file systems, mmvv uses cp(1)
     and rm(1) to accomplish the move.  The effect is equivalent to:

           rm -f destination_path && \
           cp -pRP source_file destination && \
           rm -rf source_file

EEXXIITT SSTTAATTUUSS
     The mmvv utility exits 0 on success, and >0 if an error occurs.

     The command "mv dir/afile dir" will abort with an error message.

LLEEGGAACCYY DDIIAAGGNNOOSSTTIICCSS
     In legacy mode, the command "mv dir/afile dir" will fail silently,
     returning an exit code of 0.

     For more information about legacy mode, see compat(5).

EEXXAAMMPPLLEESS
     Rename file _f_o_o to _b_a_r, overwriting _b_a_r if it already exists:

           $ mv -f foo bar

CCOOMMPPAATTIIBBIILLIITTYY
     The --hh, --nn, and --vv options are non-standard and their use in scripts is
     not recommended.

     The mmvv utility now supports HFS+ Finder and Extended Attributes and
     resource forks.  The mmvv utility will no longer strip resource forks off
     of HFS files.  For an alternative method, refer to cp(1).

SSEEEE AALLSSOO
     cp(1), rm(1), symlink(7)

SSTTAANNDDAARRDDSS
     The mmvv utility is expected to be IEEE Std 1003.2 (“POSIX.2”) compatible.

HHIISSTTOORRYY
     A mmvv command appeared in Version 1 AT&T UNIX.

macOS 15.0                      March 15, 2013                      macOS 15.0


---


# Переименуйте файл «text» в «textSIT» используя команду mv



---


# Ознакомьтесь с возможностями команды cp c помощью команды man:

CP(1)                       General Commands Manual                      CP(1)

NNAAMMEE
     ccpp – copy files

SSYYNNOOPPSSIISS
     ccpp [--RR [--HH | --LL | --PP]] [--ff | --ii | --nn] [--aaccllNNppSSssvvXXxx]
        _s_o_u_r_c_e___f_i_l_e _t_a_r_g_e_t___f_i_l_e
     ccpp [--RR [--HH | --LL | --PP]] [--ff | --ii | --nn] [--aaccllNNppSSssvvXXxx]
        _s_o_u_r_c_e___f_i_l_e _._._. _t_a_r_g_e_t___d_i_r_e_c_t_o_r_y
     ccpp [--ff | --ii | --nn] [--aaccllNNPPppSSssvvXXxx] _s_o_u_r_c_e___f_i_l_e _t_a_r_g_e_t___f_i_l_e
     ccpp [--ff | --ii | --nn] [--aaccllNNPPppSSssvvXXxx] _s_o_u_r_c_e___f_i_l_e _._._. _t_a_r_g_e_t___d_i_r_e_c_t_o_r_y

DDEESSCCRRIIPPTTIIOONN
     In the first synopsis form, the ccpp utility copies the contents of the
     _s_o_u_r_c_e___f_i_l_e to the _t_a_r_g_e_t___f_i_l_e.  In the second synopsis form, the
     contents of each named _s_o_u_r_c_e___f_i_l_e is copied to the destination
     _t_a_r_g_e_t___d_i_r_e_c_t_o_r_y.  The names of the files themselves are not changed.  If
     ccpp detects an attempt to copy a file to itself, the copy will fail.

     The following options are available:

     --HH    If the --RR option is specified, symbolic links on the command line
           are followed.  (Symbolic links encountered in the tree traversal
           are not followed.)

     --LL    If the --RR option is specified, all symbolic links are followed.

     --PP    No symbolic links are followed.  This is the default if the --RR
           option is specified.

     --RR    If _s_o_u_r_c_e___f_i_l_e designates a directory, ccpp copies the directory and
           the entire subtree connected at that point.  If the _s_o_u_r_c_e___f_i_l_e
           ends in a _/, the contents of the directory are copied rather than
           the directory itself.  This option also causes symbolic links to be
           copied, rather than indirected through, and for ccpp to create
           special files rather than copying them as normal files.  Created
           directories have the same mode as the corresponding source
           directory, unmodified by the process' umask.

           In --RR mode, ccpp will continue copying even if errors are detected.

           Note that ccpp copies hard linked files as separate files.  If you
           need to preserve hard links, consider using tar(1), cpio(1), or
           pax(1) instead.

     --aa    Archive mode.  Same as --RRppPP.  Preserves structure and attributes of
           files but not directory structure.

     --cc    copy files using clonefile(2).  Note that if clonefile(2) is not
           supported for the target filesystem, then ccpp will fallback to using
           copyfile(2) instead to ensure the copy still succeeds.

     --ff    For each existing destination pathname, remove it and create a new
           file, without prompting for confirmation regardless of its
           permissions.  (The --ff option overrides any previous --ii or --nn
           options.)

           The target file is not unlinked before the copy.  Thus, any
           existing access rights will be retained.

     --ii    Cause ccpp to write a prompt to the standard error output before
           copying a file that would overwrite an existing file.  If the
           response from the standard input begins with the character ‘y’ or
           ‘Y’, the file copy is attempted.  (The --ii option overrides any
           previous --ff or --nn options.)

     --ll    Create hard links to regular files in a hierarchy instead of
           copying.

     --NN    When used with --pp, suppress copying file flags.

     --nn    Do not overwrite an existing file.  (The --nn option overrides any
           previous --ff or --ii options.)

     --pp    Cause ccpp to preserve the following attributes of each source file
           in the copy: modification time, access time, file flags, file mode,
           user ID, and group ID, as allowed by permissions.  Access Control
           Lists (ACLs) and Extended Attributes (EAs), including resource
           forks, will also be preserved.

           If the user ID and group ID cannot be preserved, no error message
           is displayed and the exit value is not altered.

           If the source file has its set-user-ID bit on and the user ID
           cannot be preserved, the set-user-ID bit is not preserved in the
           copy's permissions.  If the source file has its set-group-ID bit on
           and the group ID cannot be preserved, the set-group-ID bit is not
           preserved in the copy's permissions.  If the source file has both
           its set-user-ID and set-group-ID bits on, and either the user ID or
           group ID cannot be preserved, neither the set-user-ID nor set-
           group-ID bits are preserved in the copy's permissions.

     --SS    Do not attempt to preserve holes in sparse files.

     --ss    Create symbolic links to regular files in a hierarchy instead of
           copying.

     --vv    Cause ccpp to be verbose, showing files as they are copied.

     --XX    Do not copy Extended Attributes (EAs) or resource forks.

     --xx    File system mount points are not traversed.

     For each destination file that already exists, its contents are
     overwritten if permissions allow.  Its mode, user ID, and group ID are
     unchanged unless the --pp option was specified.

     In the second synopsis form, _t_a_r_g_e_t___d_i_r_e_c_t_o_r_y must exist unless there is
     only one named _s_o_u_r_c_e___f_i_l_e which is a directory and the --RR flag is
     specified.

     If the destination file does not exist, the mode of the source file is
     used as modified by the file mode creation mask (uummaasskk, see csh(1)).  If
     the source file has its set-user-ID bit on, that bit is removed unless
     both the source file and the destination file are owned by the same user.
     If the source file has its set-group-ID bit on, that bit is removed
     unless both the source file and the destination file are in the same
     group and the user is a member of that group.  If both the set-user-ID
     and set-group-ID bits are set, all of the above conditions must be
     fulfilled or both bits are removed.

     Appropriate permissions are required for file creation or overwriting.

     Symbolic links are always followed unless the --RR flag is set, in which
     case symbolic links are not followed, by default.  The --HH or --LL flags (in
     conjunction with the --RR flag) cause symbolic links to be followed as
     described above.  The --HH, --LL and --PP options are ignored unless the --RR
     option is specified.  In addition, these options override each other and
     the command's actions are determined by the last one specified.

     If ccpp receives a SIGINFO (see the ssttaattuuss argument for stty(1)) signal,
     the current input and output file and the percentage complete will be
     written to the standard output.

     If ccpp encounters an I/O error during the copy, then ccpp may leave a
     partially copied _t_a_r_g_e_t___f_i_l_e in place.  ccpp specifically avoids cleaning
     up the output file in error cases to avoid further data loss in cases
     where the source may not be recoverable.  Alternatives, like install(1),
     may be preferred if stronger guarantees about the _t_a_r_g_e_t___f_i_l_e are
     required.

EEXXIITT SSTTAATTUUSS
     The ccpp utility exits 0 on success, and >0 if an error occurs.

EEXXAAMMPPLLEESS
     Make a copy of file _f_o_o named _b_a_r:

           $ cp foo bar

     Copy a group of files to the _/_t_m_p directory:

           $ cp *.txt /tmp

     Copy the directory _j_u_n_k and all of its contents (including any
     subdirectories) to the _/_t_m_p directory:

           $ cp -R junk /tmp

CCOOMMPPAATTIIBBIILLIITTYY
     Historic versions of the ccpp utility had a --rr option.  This implementation
     supports that option, however, its behavior is different from historical
     FreeBSD behavior.  Use of this option is strongly discouraged as the
     behavior is implementation-dependent.  In FreeBSD, --rr is a synonym for
     --RRLL and works the same unless modified by other flags.  Historical
     implementations of --rr differ as they copy special files as normal files
     while recreating a hierarchy.

     The --aa, --cc, --ll, --NN, --nn, --SS, --ss, --vv, --XX, and --xx options are non-standard
     and their use in scripts is not recommended.

LLEEGGAACCYY DDEESSCCRRIIPPTTIIOONN
     In legacy mode, --ff will override --ii.  Also, under the --ff option, the
     target file is always unlinked before the copy.  Thus, new access rights
     will always be set.

     In --RR mode, copying will terminate if an error is encountered.

     For more information about legacy mode, see compat(5).

SSEEEE AALLSSOO
     install(1), mv(1), rcp(1), clonefile(2), copyfile(2), umask(2), fts(3),
     compat(5), symlink(7)

SSTTAANNDDAARRDDSS
     The ccpp command is expected to be IEEE Std 1003.2 (“POSIX.2”) compatible.

HHIISSTTOORRYY
     A ccpp command appeared in Version 1 AT&T UNIX.

macOS 15.0                      March 28, 2024                      macOS 15.0


---


# Скопируйте файл «textSIT» в каталог «test2» под именем «copy.txt», используя команду cp:



---


# Ознакомьтесь с возможностями команды ln c помощью команды man:

LN(1)                       General Commands Manual                      LN(1)

NNAAMMEE
     llnn, lliinnkk – link files

SSYYNNOOPPSSIISS
     llnn [--LL | --PP | --ss [--FF]] [--ff | --iiww] [--hhnnvv] _s_o_u_r_c_e___f_i_l_e [_t_a_r_g_e_t___f_i_l_e]
     llnn [--LL | --PP | --ss [--FF]] [--ff | --iiww] [--hhnnvv] _s_o_u_r_c_e___f_i_l_e _._._. _t_a_r_g_e_t___d_i_r
     lliinnkk _s_o_u_r_c_e___f_i_l_e _t_a_r_g_e_t___f_i_l_e

DDEESSCCRRIIPPTTIIOONN
     The llnn utility creates a new directory entry (linked file) for the file
     name specified by _t_a_r_g_e_t___f_i_l_e.  The _t_a_r_g_e_t___f_i_l_e will be created with the
     same file modes as the _s_o_u_r_c_e___f_i_l_e.  It is useful for maintaining
     multiple copies of a file in many places at once without using up storage
     for the “copies”; instead, a link “points” to the original copy.  There
     are two types of links; hard links and symbolic links.  How a link
     “points” to a file is one of the differences between a hard and symbolic
     link.

     The options are as follows:

     --FF    If the target file already exists and is a directory, then remove
           it so that the link may occur.  The --FF option should be used with
           either --ff or --ii options.  If neither --ff nor --ii is specified, --ff is
           implied.  The --FF option is a no-op unless --ss is specified.

     --LL    When creating a hard link to a symbolic link, create a hard link to
           the target of the symbolic link.  This is the default.  This option
           cancels the --PP option.

     --PP    When creating a hard link to a symbolic link, create a hard link to
           the symbolic link itself.  This option cancels the --LL option.

     --ff    If the target file already exists, then unlink it so that the link
           may occur.  (The --ff option overrides any previous --ii and --ww
           options.)

     --hh    If the _t_a_r_g_e_t___f_i_l_e or _t_a_r_g_e_t___d_i_r is a symbolic link, do not follow
           it.  This is most useful with the --ff option, to replace a symlink
           which may point to a directory.

     --ii    Cause llnn to write a prompt to standard error if the target file
           exists.  If the response from the standard input begins with the
           character ‘y’ or ‘Y’, then unlink the target file so that the link
           may occur.  Otherwise, do not attempt the link.  (The --ii option
           overrides any previous --ff options.)

     --nn    Same as --hh, for compatibility with other llnn implementations.

     --ss    Create a symbolic link.

     --vv    Cause llnn to be verbose, showing files as they are processed.

     --ww    Warn if the source of a symbolic link does not currently exist.

     By default, llnn makes _h_a_r_d links.  A hard link to a file is
     indistinguishable from the original directory entry; any changes to a
     file are effectively independent of the name used to reference the file.
     Directories may not be hardlinked, and hard links may not span file
     systems.

     A symbolic link contains the name of the file to which it is linked.  The
     referenced file is used when an open(2) operation is performed on the
     link.  A stat(2) on a symbolic link will return the linked-to file; an
     lstat(2) must be done to obtain information about the link.  The
     readlink(2) call may be used to read the contents of a symbolic link.
     Symbolic links may span file systems and may refer to directories.

     Given one or two arguments, llnn creates a link to an existing file
     _s_o_u_r_c_e___f_i_l_e.  If _t_a_r_g_e_t___f_i_l_e is given, the link has that name;
     _t_a_r_g_e_t___f_i_l_e may also be a directory in which to place the link; otherwise
     it is placed in the current directory.  If only the directory is
     specified, the link will be made to the last component of _s_o_u_r_c_e___f_i_l_e.

     Given more than two arguments, llnn makes links in _t_a_r_g_e_t___d_i_r to all the
     named source files.  The links made will have the same name as the files
     being linked to.

     When the utility is called as lliinnkk, exactly two arguments must be
     supplied, neither of which may specify a directory.  No options may be
     supplied in this simple mode of operation, which performs a link(2)
     operation using the two passed arguments.

EEXXAAMMPPLLEESS
     Create a symbolic link named _/_h_o_m_e_/_s_r_c and point it to _/_u_s_r_/_s_r_c:

           # ln -s /usr/src /home/src

     Hard link _/_u_s_r_/_l_o_c_a_l_/_b_i_n_/_f_o_o_p_r_o_g to file _/_u_s_r_/_l_o_c_a_l_/_b_i_n_/_f_o_o_p_r_o_g_-_1_._0:

           # ln /usr/local/bin/fooprog-1.0 /usr/local/bin/fooprog

     As an exercise, try the following commands:

           # ls -i /bin/[
           11553 /bin/[
           # ls -i /bin/test
           11553 /bin/test

     Note that both files have the same inode; that is, _/_b_i_n_/_[ is essentially
     an alias for the test(1) command.  This hard link exists so test(1) may
     be invoked from shell scripts, for example, using the if [ ] construct.

     In the next example, the second call to llnn removes the original _f_o_o and
     creates a replacement pointing to _b_a_z:

           # mkdir bar baz
           # ln -s bar foo
           # ln -shf baz foo

     Without the --hh option, this would instead leave _f_o_o pointing to _b_a_r and
     inside _f_o_o create a new symlink _b_a_z pointing to itself.  This results
     from directory-walking.

     An easy rule to remember is that the argument order for llnn is the same as
     for cp(1): The first argument needs to exist, the second one is created.

CCOOMMPPAATTIIBBIILLIITTYY
     The --hh, --ii, --nn, --vv and --ww options are non-standard and their use in
     scripts is not recommended.  They are provided solely for compatibility
     with other llnn implementations.

     The --FF option is a FreeBSD extension and should not be used in portable
     scripts.

SSEEEE AALLSSOO
     link(2), lstat(2), readlink(2), stat(2), symlink(2), symlink(7)

SSTTAANNDDAARRDDSS
     The llnn utility conforms to IEEE Std 1003.2-1992 (“POSIX.2”).

     The simplified lliinnkk command conforms to Version 2 of the Single UNIX
     Specification (“SUSv2”).

HHIISSTTOORRYY
     An llnn command appeared in Version 1 AT&T UNIX.

macOS 15.0                       May 10, 2021                       macOS 15.0


---


# Создайте жесткую ссылку «link» на файл «copy.txt» используя команду ln:



---


# Создайте символическую ссылку «simlink» на файл «copy.txt» используя команду ln:



---


# Просмотрите результаты в текущем каталоге при помощи команды ls с аргументами la:

total 0
drwxr-xr-x   3 idbolshakov  staff    96 Feb  8 14:57 .
drwxr-xr-x+ 61 idbolshakov  staff  1952 Feb  8 14:57 ..
drwxr-xr-x   6 idbolshakov  staff   192 Feb  8 14:57 test2

./test2:
total 0
drwxr-xr-x  6 idbolshakov  staff  192 Feb  8 14:57 .
drwxr-xr-x  3 idbolshakov  staff   96 Feb  8 14:57 ..
-rw-r--r--  2 idbolshakov  staff    0 Feb  8 14:57 copy.txt
-rw-r--r--  2 idbolshakov  staff    0 Feb  8 14:57 copy.txt.hlink
lrwxr-xr-x  1 idbolshakov  staff   14 Feb  8 14:57 copy.txt.slink -> test2/copy.txt
-rw-r--r--  1 idbolshakov  staff    0 Feb  8 14:57 textSIT


---


